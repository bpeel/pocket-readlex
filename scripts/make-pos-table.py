#!/usr/bin/python3

# Pocket ReadLex â€“ An offline app for ReadLex
# Copyright (C) 2024  Neil Roberts
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# This is a helper script to generate a table of pairs of part of
# speech tags. The numbers of the table represent the preference value
# that given one part of speech the other part of speech follows it.

import nltk
import sys
import re


POS_REMAP = {
    "AT": "AT0",
    "BE": "VVB",
    "BED": "VVD",
    "BEG": "VVG",
    "BEN": "VVN",
    "BEZ": "VVZ",
    "CC": "CJC",
    "CD": "CRD",
    "CS": "CJS",
    "DO": "VVB",
    "DOD": "VVD",
    "DOG": "VVG",
    "DON": "VVN",
    "DOZ": "VVZ",
    "DT": "DT0",
    "DTS": "DT0",
    "EX": "EX0",
    "HV": "VVB",
    "HVD": "VVD",
    "HVG": "VVG",
    "HVN": "VVN",
    "HVZ": "VVZ",
    "IN": "PRP",
    "JJ": "AJ0",
    "JJR": "AJC",
    "JJT": "AJS",
    "MD": "VM0",
    "NN": "NN1",
    "NNS": "NN2",
    "NP": "NP0",
    "PPL": "PNX",
    "PPLS": "PNX",
    "PPO": "PNP",
    "PPS": "PNP",
    "PPSS": "PNP",
    "PP$": "DPS",
    "QL": "AVQ",
    "RB": "AV0",
    "RBR": "AV0",
    "RBT": "AV0",
    "TO": "TO0",
    "VB": "VVB",
    "VBD": "VVD",
    "VBG": "VVG",
    "VBN": "VVN",
    "VBZ": "VVZ",
    "WP$": "PNQ",
    "WPO": "PNQ",
    "WPS": "PNQ",
}

# This needs to match the order in compiledb.rs
POS_NUMBERS = [
    "AJ0", "AJC", "AJS", "AT0", "AV0", "AVP", "AVQ", "CJC", "CJS",
    "CJT", "CRD", "DPS", "DT0", "DTQ", "EX0", "ITJ", "NN0", "NN1",
    "NN2", "NP0", "ORD", "PNI", "PNP", "PNQ", "PNX", "POS", "PRE",
    "PRF", "PRP", "TO0", "UNC", "VM0", "VVB", "VVD", "VVG", "VVI",
    "VVN", "VVZ", "XX0", "ZZ0",
]

N_POS = len(POS_NUMBERS) + 1
SENTENCE_START = N_POS - 1

def count_pos_pairs():
    table = [0] * (N_POS * N_POS)
    last_pos = SENTENCE_START

    for word, pos in nltk.corpus.brown.tagged_words():
        if word == ".":
            last_pos = SENTENCE_START
            continue

        try:
            mapped_pos = POS_REMAP[pos]
        except KeyError:
            mapped_pos = None
            pos_num = None
        else:
            pos_num = POS_NUMBERS.index(mapped_pos)

        if last_pos is not None and pos_num is not None:
            table[last_pos * N_POS + pos_num] += 1

        last_pos = pos_num

    return table


def make_pos_table(count_table):
    pos_table = []

    for left in range(N_POS):
        # Get a sorted list of counts combined with the pos number
        counts = list(map(lambda d: (d[1], d[0]),
                          enumerate(count_table[left * N_POS:(left + 1)
                                                * N_POS])))
        counts.sort()

        # Convert the list into a mapping from pos number to score
        # where the score is the position in the sorted list
        scores = [None] * len(counts)
        for score, (count, pos) in enumerate(counts):
            if score > 0 and count == counts[score - 1][0]:
                # Whenever the scores are equal, set the score to
                # the same as the previous one so that the
                # transliterator will fall back to picking the most
                # frequent one.
                scores[pos] = scores[counts[score - 1][1]]
            else:
                scores[pos] = score

        pos_table.extend(scores)

    return pos_table


def extract_copyright_blurb():
    in_blurb = False
    comment_re = re.compile(r'^#(?!!)')

    with open(sys.argv[0], 'r', encoding='utf-8') as f:
        for line in f:
            md = comment_re.match(line)

            if md is not None:
                in_blurb = True
                print(f"//{line[md.end(0):]}", end='')
            elif in_blurb:
                break


print("// Automatically generated by make-pos-table.py\n")

extract_copyright_blurb()

print("\n"
      f"pub const N_POS: usize = {N_POS};"
      "\n"
      f"pub static PAIR_PRIORITIES: [u8; {N_POS * N_POS}] = [")

table = make_pos_table(count_pos_pairs())

print("    //         ", end='')

for pos in POS_NUMBERS:
    print(f" {pos}", end='')

print(" sst")

for left in range(N_POS):
    if left == SENTENCE_START:
        name = "sst"
    else:
        name = POS_NUMBERS[left]

    print("    /* ", name, " */", end='')

    for right in range(N_POS):
        print("{: 3},".format(table[left * N_POS + right]), end='')

    print()

print("];")
